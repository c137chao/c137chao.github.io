<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>6.s081 lab8 lock - Summer Blog Space</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="notebook on 6.s081 lab">
		<meta property="og:title" content="6.s081 lab8 lock" />
<meta property="og:description" content="notebook on 6.s081 lab" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://c137chao.github.io/6.s081/lab8-lock/" /><meta property="article:section" content="6.s081" />
<meta property="article:published_time" content="2021-01-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-21T00:00:00+00:00" />


		<meta itemprop="name" content="6.s081 lab8 lock">
<meta itemprop="description" content="notebook on 6.s081 lab"><meta itemprop="datePublished" content="2021-01-21T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-01-21T00:00:00+00:00" />
<meta itemprop="wordCount" content="1093">
<meta itemprop="keywords" content="Operating System," />
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="summer" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="https://pic.imgdb.cn/item/651e2920c458853aef0fc060.jpg">
				</div><div class="logo__item logo__text">
					<div class="logo__title">summer</div>
					<div class="logo__tagline">summer blog space</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/blog/cs162-proj1/">
				
				<span class="menu__text">CS162 Project1 Userprograme</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/cs61/cs61b-gitlet/">
				
				<span class="menu__text">CS61B-实现一个简易的git</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/blog/cs61c-cpu/">
				
				<span class="menu__text">CS61C-简易的二级流水risv-v CPU</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/blog/tinykv-lab2a/">
				
				<span class="menu__text">tinykv lab2a raft</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/blog/tinykv-lab2b/">
				
				<span class="menu__text">tinykv lab2b kvraft</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/blog/tinykv-lab2c/">
				
				<span class="menu__text">tinykv lab2c snapshot</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">6.s081 lab8 lock</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">Summer</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2021-01-21T00:00:00Z">January 21, 2021</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/6.s081/" rel="category">6.s081</a>
	</span>
</div></div>
		</header>
		
	<figure class="post__thumbnail thumbnail">
		
		<img class="thumbnail__image" src="https://pic.imgdb.cn/item/6520d45ac458853aef1079fb.jpg" alt="6.s081 lab8 lock">
		
	</figure>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#1memory-allocator">1.Memory allocator</a></li>
    <li><a href="#2-buffer-cache">2 Buffer Cache</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<p><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html">官方实验指导书传送门</a></p>
<h2 id="1memory-allocator">1.Memory allocator</h2>
<blockquote>
<p>原本的内存分配锁的粒度比较大，全局使用一个freelist和用来互斥访问内存申请释放的lock (kmem) 虽然能够维持互斥访问的正确性，但并发效率低，所以这个task就是修改原本的内存分配，让每个CPU都持有一个freelist和lock，自己的内存自己管理，当内存不够的时候，从其他CPU的freelist那里获取内存，从而让内存管理能够并发运行。</p>
</blockquote>
<p>Your Job里面说了要使用原来的kmem，换而言之就是不要把freelist和lock些加到cpu的结构体里面去(估计这样要修改的内容会多到爆炸)，所以就把原来的kmem改成一个数组。​</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">struct</span> {
  <span style="color:#66d9ef">struct</span> spinlock lock;
  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>freelist;
} kmem[NCPU];
</code></pre></div><p>相应修改kmem的初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">kinit</span>()
{
  <span style="color:#66d9ef">for</span>(uint i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCPU; i<span style="color:#f92672">++</span>){
    initlock(<span style="color:#f92672">&amp;</span>kmem[i].lock, <span style="color:#e6db74">&#34;kmem&#34;</span>); <span style="color:#75715e">// 暂时将所有的锁命名为kmem
</span><span style="color:#75715e"></span>  }
  freerange(end, (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)PHYSTOP);
}

</code></pre></div><p>修改kfree和kalloc，注意cpuid()要关中断，或者可以尝试在内存分配时整个持有所的过程关中断(不然被锁住的那个cpu要一直等着时间片轮转回来，但这样关中断又感觉太暴力)，都可以通过</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">kfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pa)
{
  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;  

  <span style="color:#66d9ef">if</span>(((uint64)pa <span style="color:#f92672">%</span> PGSIZE) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)pa <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">||</span> (uint64)pa <span style="color:#f92672">&gt;=</span> PHYSTOP)
    panic(<span style="color:#e6db74">&#34;kfree&#34;</span>);

  <span style="color:#75715e">// Fill with junk to catch dangling refs.
</span><span style="color:#75715e"></span>  memset(pa, <span style="color:#ae81ff">1</span>, PGSIZE);

  r <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> run<span style="color:#f92672">*</span>)pa;
  
  push_off();
  uint cid <span style="color:#f92672">=</span> cpuid();
  pop_off();
  
  acquire(<span style="color:#f92672">&amp;</span>kmem[cid].lock);
  r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> kmem[cid].freelist;
  kmem[cid].freelist <span style="color:#f92672">=</span> r;
  release(<span style="color:#f92672">&amp;</span>kmem[cid].lock);
}
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#a6e22e">kalloc</span>(<span style="color:#66d9ef">void</span>)
{
  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
  
  push_off();
  uint cid <span style="color:#f92672">=</span> cpuid();
  pop_off();
  
  acquire(<span style="color:#f92672">&amp;</span>kmem[cid].lock);
  r <span style="color:#f92672">=</span> kmem[cid].freelist;
  <span style="color:#66d9ef">if</span>(r){
    kmem[cid].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
  }<span style="color:#66d9ef">else</span>{
    <span style="color:#66d9ef">for</span>(uint i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCPU; i<span style="color:#f92672">++</span>){
      <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">==</span> cid) <span style="color:#66d9ef">continue</span>;
      acquire(<span style="color:#f92672">&amp;</span>kmem[i].lock);
      <span style="color:#66d9ef">if</span>(kmem[i].freelist){
        r <span style="color:#f92672">=</span> kmem[i].freelist;
        kmem[i].freelist <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
        release(<span style="color:#f92672">&amp;</span>kmem[i].lock);
        <span style="color:#66d9ef">break</span>;
      }
      release(<span style="color:#f92672">&amp;</span>kmem[i].lock);   
    }
  }
  release(<span style="color:#f92672">&amp;</span>kmem[cid].lock);

  <span style="color:#66d9ef">if</span>(r)
    memset((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)r;
}

</code></pre></div><p>最后就是格式化kmem(把lock的名字编程kmem1, kmem2之类的)，按照hint里提到的，就是要使用sprintf，这里不演示了。</p>
<h2 id="2-buffer-cache">2 Buffer Cache</h2>
<p>感觉上就是复杂版的task1，但实际做起来发现还是很难的</p>
<p>原本是一个双链表，现在要组织成哈希表，类似于lab 7里那样</p>
<p>也没理解为什么改用时间戳来实现LRU，原来的LRU挺好的说</p>
<p>bucket的结构改来改去，还是沿用原来的双链表，bcache buffer必须使用原来的静态数组buf，改动起来很受限，所以不管怎么改动都是通过指针去重新组织原来的数组，先通过再去想优化的问题</p>
<p>bget那里花了很多时间，想要做到安全并发还是很困难的</p>
<h4 id="1使用hash-bucket为每个bucket设置一个lock">(1)使用hash bucket，为每个bucket设置一个lock</h4>
<p>将原来的双链表改成哈希表，因为经常要从别的bucket steal空闲块，所以还是沿用双链表结构，方便插入删除</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#define NBUCKET 13
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> bucket{
  <span style="color:#66d9ef">struct</span> spinlock lock;
  <span style="color:#66d9ef">struct</span> buf head;
};

<span style="color:#66d9ef">struct</span> {
  <span style="color:#66d9ef">struct</span> bucket hash[NBUCKET];
  <span style="color:#66d9ef">struct</span> buf buf[NBUF];
} bcache;
</code></pre></div><p>(2)对应修改binit</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">binit</span>(<span style="color:#66d9ef">void</span>)
{
  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;

  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NBUCKET; i<span style="color:#f92672">++</span>){
    initlock(<span style="color:#f92672">&amp;</span>bcache.hash[i].lock, <span style="color:#e6db74">&#34;bcache&#34;</span>);
    <span style="color:#75715e">// Create linked list of buffers
</span><span style="color:#75715e"></span>    bcache.hash[i].head.prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.hash[i].head;
    bcache.hash[i].head.next <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.hash[i].head;
  }

  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf<span style="color:#f92672">+</span>NBUF; b<span style="color:#f92672">++</span>){
    <span style="color:#66d9ef">int</span> hashkey <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">%</span> NBUCKET;
    b<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next;
    b<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head;
    initsleeplock(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock, <span style="color:#e6db74">&#34;buffer&#34;</span>);
    bcache.hash[hashkey].head.next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> b;
    bcache.hash[hashkey].head.next <span style="color:#f92672">=</span> b;
  }
}
</code></pre></div><p>(3)在hash表中查找磁盘块要加锁()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
<span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
{
  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
  <span style="color:#66d9ef">int</span> hashkey <span style="color:#f92672">=</span> blockno <span style="color:#f92672">%</span> NBUCKET;
  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);

  <span style="color:#75715e">// Is the block already cached?
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next){
    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno){
      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
      release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
      acquiresleep(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
      <span style="color:#66d9ef">return</span> b;
    }
  }

  <span style="color:#75715e">// Not cached.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Recycle the least recently used (LRU) unused buffer.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">/*
</span><span style="color:#75715e">    .......
</span><span style="color:#75715e">    这块改动比较大，也是难点，留在最后, 而且不小心就会有死锁问题
</span><span style="color:#75715e">  */</span>
}
</code></pre></div><p>(4)增加time stamp(时间戳)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">struct</span> buf {
  <span style="color:#66d9ef">int</span> valid;   <span style="color:#75715e">// has data been read from disk?
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> disk;    <span style="color:#75715e">// does disk &#34;own&#34; buf?
</span><span style="color:#75715e"></span>  uint dev;
  uint blockno;
  <span style="color:#66d9ef">struct</span> sleeplock lock;
  uint refcnt;
  uint timestamp;   <span style="color:#75715e">// time stamp 
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>prev; <span style="color:#75715e">// LRU cache list
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>next;
  uchar data[BSIZE];
};
</code></pre></div><p>brelse发生了变化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">brelse</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
{
  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>holdingsleep(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock))
    panic(<span style="color:#e6db74">&#34;brelse&#34;</span>);

  releasesleep(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
  <span style="color:#66d9ef">int</span> hashkey <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">%</span> NBUCKET;
  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
  <span style="color:#75715e">//时间戳只要在brelse中refcnt为0的时候更新即可，只有refcnt为0才涉及淘汰
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
    acquire(<span style="color:#f92672">&amp;</span>tickslock);
    b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">=</span> ticks;
    release(<span style="color:#f92672">&amp;</span>tickslock);
  }
  release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
}
</code></pre></div><p>因为修改了bcache，其他部分结构也保持一致</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">bpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b) {
  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">%</span> NBUCKET].lock);
  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
  release(<span style="color:#f92672">&amp;</span>bcache.hash[b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">%</span> NBUCKET].lock);
}

<span style="color:#66d9ef">void</span>
<span style="color:#a6e22e">bunpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b) {
  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">%</span> NBUCKET].lock);
  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
  release(<span style="color:#f92672">&amp;</span>bcache.hash[b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">%</span> NBUCKET].lock);
}
</code></pre></div><hr>
<p><strong>前面的改动大体是这样，有些细节可能要改动</strong></p>
<p>下面就是这个实验的重头戏，完善bget</p>
<blockquote>
<p>这部分要做到安全并发还是挺困难的，主要就是两个问题：死锁 or 同一个扇区出现多个缓存.
刚开始虽然通过了但发现还是有一些问题，也看了两三个别人的版本</p>
</blockquote>
<p>先看两个make grade能通过的版本，但我自己感觉有地方不对劲(第二个是开始自己写的通过的，第一个是看了别人的感觉他的代码结构看起来更漂亮试着写的，<a href="http://xv6.dgs.zone/labs/answers/lab8.html">http://xv6.dgs.zone/labs/answers/lab8.html</a>),</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
<span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
{
  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
  <span style="color:#66d9ef">int</span> hashkey <span style="color:#f92672">=</span> blockno <span style="color:#f92672">%</span> NBUCKET;

  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);

  <span style="color:#75715e">// Is the block already cached?
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next){
    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno){
      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;    
      release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
      acquiresleep(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
      <span style="color:#66d9ef">return</span> b;
    }
  }
  <span style="color:#75715e">// release(&amp;bcache.hash[hashkey].lock);
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// Not cached.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span> mintimestap;
  <span style="color:#66d9ef">int</span> minindex <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

  <span style="color:#75715e">// Recycle the least recently used (LRU) unused buffer.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// get a free block of min time stamp from hashtable 
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> hashkey, n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; n <span style="color:#f92672">&lt;</span> NBUCKET; n<span style="color:#f92672">++</span>, i <span style="color:#f92672">=</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> NBUCKET){
  
    <span style="color:#75715e">// 此时hash[i].lock如果被另一个进程p2持有，且p2又在尝试获取hash[hashkey].lock
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 则会发生死锁
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 原文里还加了一个holding(lock)的判断，但这只能判断当前CPU核心的，多核间仍有可能产生死锁
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> hashkey)  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[i].lock);
    <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[i].head.prev; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[i].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>prev){
      <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>mintimestap <span style="color:#f92672">||</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> mintimestap<span style="color:#f92672">-&gt;</span>timestamp)) {
        mintimestap <span style="color:#f92672">=</span> b;
        minindex <span style="color:#f92672">=</span> i;
      }
    }
    <span style="color:#66d9ef">if</span>(mintimestap) <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> hashkey) release(<span style="color:#f92672">&amp;</span>bcache.hash[i].lock);
  }
  
  <span style="color:#66d9ef">if</span>(mintimestap) {
    <span style="color:#66d9ef">if</span>(hashkey <span style="color:#f92672">!=</span> minindex) {

      <span style="color:#75715e">// delete b from old bucket 
</span><span style="color:#75715e"></span>      mintimestap<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mintimestap<span style="color:#f92672">-&gt;</span>next;
      mintimestap<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> mintimestap<span style="color:#f92672">-&gt;</span>prev;
      release(<span style="color:#f92672">&amp;</span>bcache.hash[minindex].lock);
      
      <span style="color:#75715e">// insert b to new bucket
</span><span style="color:#75715e"></span>      mintimestap<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next;
      mintimestap<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head;
      bcache.hash[hashkey].head.next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> mintimestap;
      bcache.hash[hashkey].head.next <span style="color:#f92672">=</span> mintimestap;
    } 
    mintimestap<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
    mintimestap<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
    mintimestap<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    mintimestap<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    
    release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
    acquiresleep(<span style="color:#f92672">&amp;</span>mintimestap<span style="color:#f92672">-&gt;</span>lock);
    <span style="color:#66d9ef">return</span> mintimestap;
  }
  panic(<span style="color:#e6db74">&#34;bget: no buffers&#34;</span>);
}
</code></pre></div><p>当需要去从其他bucket获取buffer block时，需要持有两个锁，处理不当会出现一种死锁问题，p1锁住了hash[<strong>i</strong>]，去hash[<strong>j</strong>]查找空闲块，p2锁住了hash[<strong>j</strong>]，去hash[<strong>i</strong>]查找空闲块，p1持有hash[<strong>i</strong>]等待hash[<strong>j</strong>]，p2持有hash[<strong>i</strong>]等待hash[<em><strong>i</strong></em>], p1和p2出现死锁，课上曾提过给锁排序可以解决问题(后面可以看到)。</p>
<p>我开始想的是打破两个锁的死锁，那就让进程同时只持有一个hash锁(依旧有隐患)，我只有要读取或者修改hash[<em><strong>i</strong></em>]时才会锁住hash[<em><strong>i</strong></em>]，当我去hash[<em><strong>j</strong></em>]获取空闲块时，hash[<em><strong>i</strong></em>]的锁可以暂时释放掉，当我找到以后回来修改hash[<em><strong>i</strong></em>]时再去重新获取锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">// T.T 自己写的太臃肿了
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>i
<span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
{
  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
  <span style="color:#66d9ef">int</span> hashkey <span style="color:#f92672">=</span> blockno <span style="color:#f92672">%</span> NBUCKET;

  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);

  <span style="color:#75715e">// Is the block already cached?
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next){
    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno){
      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;     
      release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
      acquiresleep(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
      <span style="color:#66d9ef">return</span> b;
    }
  }

  <span style="color:#75715e">// Not cached.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span> mintimestap <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> minindex <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

  <span style="color:#75715e">// find free block from cur bucket
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[hashkey].head.prev; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>prev){
      <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>mintimestap <span style="color:#f92672">||</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> mintimestap<span style="color:#f92672">-&gt;</span>timestamp)) {
        mintimestap <span style="color:#f92672">=</span> b;
      }
  }
  <span style="color:#66d9ef">if</span>(mintimestap){
    mintimestap<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
    mintimestap<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
    mintimestap<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    mintimestap<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    
    release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
    acquiresleep(<span style="color:#f92672">&amp;</span>mintimestap<span style="color:#f92672">-&gt;</span>lock);
    <span style="color:#66d9ef">return</span> mintimestap;
  }


  release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
 <span style="color:#75715e">// find free block from other bucket
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> NBUCKET; i<span style="color:#f92672">++</span>){
    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">==</span> hashkey) <span style="color:#66d9ef">continue</span>;
    acquire(<span style="color:#f92672">&amp;</span>bcache.hash[i].lock);
    <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[i].head.prev; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[i].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>prev){
      <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>mintimestap <span style="color:#f92672">||</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> mintimestap<span style="color:#f92672">-&gt;</span>timestamp)) {
        mintimestap <span style="color:#f92672">=</span> b;
        minindex <span style="color:#f92672">=</span> i;
      }
    }
    <span style="color:#66d9ef">if</span>(mintimestap) <span style="color:#66d9ef">break</span>;
    release(<span style="color:#f92672">&amp;</span>bcache.hash[i].lock);
  }
  
  <span style="color:#66d9ef">if</span>(mintimestap) {
    <span style="color:#66d9ef">if</span>(hashkey <span style="color:#f92672">!=</span> minindex) {
      <span style="color:#75715e">// delete b from old bucket 
</span><span style="color:#75715e"></span>      mintimestap<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mintimestap<span style="color:#f92672">-&gt;</span>next;
      mintimestap<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> mintimestap<span style="color:#f92672">-&gt;</span>prev;
      release(<span style="color:#f92672">&amp;</span>bcache.hash[minindex].lock);
      
      acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
      <span style="color:#75715e">// insert b to new bucket
</span><span style="color:#75715e"></span>      mintimestap<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next;
      mintimestap<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head;
      bcache.hash[hashkey].head.next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> mintimestap;
      bcache.hash[hashkey].head.next <span style="color:#f92672">=</span> mintimestap;
    } <span style="color:#66d9ef">else</span> {
      acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
    } 
    mintimestap<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
    mintimestap<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
    mintimestap<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    mintimestap<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    
    release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
    acquiresleep(<span style="color:#f92672">&amp;</span>mintimestap<span style="color:#f92672">-&gt;</span>lock);
    <span style="color:#66d9ef">return</span> mintimestap;
  }
  panic(<span style="color:#e6db74">&#34;bget: no buffers&#34;</span>);
}
</code></pre></div><p><img src="MIT6.s081Operating%20System/lab%2008%20-%20locks/image/image.png" alt=""></p>
<p>这样使用锁的隐患是：p1在缓存里没有找到blockno, 再去其他bucket获取空闲块,同时另一个进程p2也在找blockno，而p1没有全程锁住当前的bucket，于是p2没找到也去其他bucket里去找，他们都把blockno给写进来了，也就是说，导致了一个扇区对应了两个缓存，十分危险，而且minstamp在查找时也没有锁来保护，所以不能破坏同时持有两个锁这个条件</p>
<p><strong>解决办法</strong>:使用一对读写锁，写锁(大锁)整个hash table只有一个，读锁(小锁)每个bucket对应一个，读取 buf的时候，获取对应bucket的读锁，而如果发生缓存缺失，想要写入缓存，需要获取写锁和相关bucket的读锁，即同时只能有一个进程尝试向buf中写入扇区</p>
<p>总结前面的问题出现的原因</p>
<ul>
<li>同时有两个或者以上的进程尝试获取空闲块</li>
<li>尝试失败发生死锁</li>
<li>尝试成功，有可能都在提取同一个扇区的缓存</li>
</ul>
<p>而读写锁的目标打破多个进程能够修改hash table的条件</p>
<p>为了避免死锁，应该先获取写锁(大锁)，在获取读锁(小锁)，即按顺序获取锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
<span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
{
  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
  <span style="color:#66d9ef">int</span> hashkey <span style="color:#f92672">=</span> blockno <span style="color:#f92672">%</span> NBUCKET;

  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);

  <span style="color:#75715e">// Is the block already cached?
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next){
    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno){
      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;         
      acquire(<span style="color:#f92672">&amp;</span>tickslock);
      b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">=</span> ticks;
      release(<span style="color:#f92672">&amp;</span>tickslock);
      release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);

      acquiresleep(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
      <span style="color:#66d9ef">return</span> b;
    }
  }

  <span style="color:#75715e">// Not cached.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span> mintimestap <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">int</span> minindex <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

  release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
  acquire(<span style="color:#f92672">&amp;</span>bcache.write);
  acquire(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);

  <span style="color:#75715e">// 这里要重新检查一遍，因为上面锁的的释放获取并不是原子的，还是有被打断的可能
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next){
    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno){
      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;         
      acquire(<span style="color:#f92672">&amp;</span>tickslock);
      b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">=</span> ticks;
      release(<span style="color:#f92672">&amp;</span>tickslock);
      release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
      release(<span style="color:#f92672">&amp;</span>bcache.write);
      acquiresleep(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
      <span style="color:#66d9ef">return</span> b;
    }
  }

  <span style="color:#75715e">// find free block from cur bucket
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> hashkey, n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; n <span style="color:#f92672">&lt;</span> NBUCKET; n<span style="color:#f92672">++</span>, i <span style="color:#f92672">=</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> NBUCKET){
    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> hashkey) acquire(<span style="color:#f92672">&amp;</span>bcache.hash[i].lock);
    <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.hash[i].head.prev; b <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>bcache.hash[i].head; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>prev){
      <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>mintimestap <span style="color:#f92672">||</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> mintimestap<span style="color:#f92672">-&gt;</span>timestamp)) {
        mintimestap <span style="color:#f92672">=</span> b;
        minindex <span style="color:#f92672">=</span> i;
      }
    }
    <span style="color:#66d9ef">if</span>(mintimestap)  <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> hashkey) release(<span style="color:#f92672">&amp;</span>bcache.hash[i].lock);
  }
  
  <span style="color:#66d9ef">if</span>(mintimestap) {
    <span style="color:#66d9ef">if</span>(hashkey <span style="color:#f92672">!=</span> minindex) {
    
      <span style="color:#75715e">// delete b from old bucket 
</span><span style="color:#75715e"></span>      mintimestap<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mintimestap<span style="color:#f92672">-&gt;</span>next;
      mintimestap<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> mintimestap<span style="color:#f92672">-&gt;</span>prev;
      release(<span style="color:#f92672">&amp;</span>bcache.hash[minindex].lock);  
      
      <span style="color:#75715e">// insert b to new bucket
</span><span style="color:#75715e"></span>      mintimestap<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> bcache.hash[hashkey].head.next;
      mintimestap<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.hash[hashkey].head;
      bcache.hash[hashkey].head.next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> mintimestap;
      bcache.hash[hashkey].head.next <span style="color:#f92672">=</span> mintimestap;
    }
    mintimestap<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
    mintimestap<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
    mintimestap<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    mintimestap<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    
    release(<span style="color:#f92672">&amp;</span>bcache.hash[hashkey].lock);
    release(<span style="color:#f92672">&amp;</span>bcache.write);

    acquiresleep(<span style="color:#f92672">&amp;</span>mintimestap<span style="color:#f92672">-&gt;</span>lock);
    <span style="color:#66d9ef">return</span> mintimestap;
  }
  panic(<span style="color:#e6db74">&#34;bget: no buffers&#34;</span>);
}
</code></pre></div><p><img src="MIT6.s081Operating%20System/lab%2008%20-%20locks/image/image_1.png" alt=""></p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/operating-system/" rel="tag">Operating System</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Summer avatar" src="https://pic.imgdb.cn/item/651e2920c458853aef0fc060.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Summer</span>
	</div>
	<div class="authorbox__description">
		newbie programer
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/6.s081/lab7-multithread/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">6.s081 lab7 multithreads</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/6.s081/lab9-filesys/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">6.s081 lab9 filesys</p>
		</a>
	</div>
</nav>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://www.bing.com/">
		<label>
			<input class="widget-search__field" type="search" placeholder="SEARCH…" value="" name="q" aria-label="SEARCH…">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="http://c137chao.github.io/">
	</form>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/blog/tinykv-lab2c/">tinykv lab2c snapshot</a></li>
			<li class="widget__item"><a class="widget__link" href="/blog/tinykv-lab2b/">tinykv lab2b kvraft</a></li>
			<li class="widget__item"><a class="widget__link" href="/blog/tinykv-lab2a/">tinykv lab2a raft</a></li>
			<li class="widget__item"><a class="widget__link" href="/blog/cs162-proj1/">CS162 Project1 Userprograme</a></li>
			<li class="widget__item"><a class="widget__link" href="/blog/cs61c-cpu/">CS61C-简易的二级流水risv-v CPU</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/distribute-storage/" title="distribute storage">distribute storage</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/operating-system/" title="Operating System">Operating System</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 Summer.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>